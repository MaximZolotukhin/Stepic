"""
Подвиг 6. Имеется следующий многомерный список:
d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
С помощью рекурсивной функции get_line_list создать на его основе одномерный список из значений элементов списка d.
Функция должна возвращать новый созданный одномерный список.  (Только возвращать, выводить на экран ничего не нужно.)

Вызывать функцию не нужно, только объявить со следующей сигнатурой:

def get_line_list(d,a=[]): ...

где d - исходный список; a - новый формируемый.

"""
d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]

def get_line_list(d,a=[]):
    for val in d: # Перебираю значения в списке
        if type(val) == list: # Если это список
            get_line_list(val, a) # Если это список запускаю рекурсию
        else:
            a.append(val) # Если это значение, то добавляем значение в список

    return a


print(set(get_line_list(d)))

# Решение через две функции
# def get_line_list(d,a=[]):
#     for val in d:
#         if type(val) == list:
#             a.append(get_line_list(val, a))
#         else:
#             a.append(val)
#     return a
#
# def result(fun):
#     a = fun
#     b = []
#     for val in a:
#         if type(val) != list:
#             b.append(val)
#             # a.remove(val)
#         else:
#             continue
#
#     return b

#
# ------------------ Промежуточное решение.
# def get_line_list(d,a=[]):
#     for val in d: # Перебираю значения в списке
#         if type(val) == list: # Если это список, входим в следующую проверку
#             if type(val) != list: # Проверяю если значение не спиок сохраняю в список
#                 a.append(val)
#             else:
#                 get_line_list(val, a) # Если это список запускаю рекурсию
#         else:
#             a.append(val) # Если при первой итерации это не списко я просто добавляю значение к списку.
#
#     return a